---
keywords: [advanced, ethereum, bitcoin, btc address, addresses, eth address ]
---

import useBaseUrl from "@docusaurus/useBaseUrl";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Generating addresses

<MarkdownChipRow labels={["Advanced", "Chain Fusion" ]} />

## Overview

Different blockchain networks may use a different address format or encryption algorithm. To send a transaction to another chain from an ICP canister, your canister will need to have an address for that chain so it can receive the transaction's response.

For Bitcoin transactions, a canister must have a Bitcoin address in the form of a hash value.

For Ethereum and EVM-compatible chains, your canister will need an ETH wallet address.

For other blockchains, it will depend on the chain's native form of address and how ICP communicates with the chain, such as through HTTPS outcalls and Threshold ECDSA signatures.

Examples of how to generate addresses for Bitcoin, Ethereum or EVM, and other unique chains can be found below.

:::caution

This page is not an exhaustive list of supported chains. An ICP canister can interact with any chain that is EVM-compatible or supports ECDSA signatures.

:::

## Bitcoin

A Bitcoin address is a hash value. There are currently two types of Bitcoin addresses: P2SH and P2PKH. An address's full public key cannot be provided when sending transactions, so to redeem transactions sent to your Bitcoin address, you must provide both the transaction signature and the public key used to sign the transaction.

To submit and receive Bitcoin transactions in a canister, you need to generate a Bitcoin address for that canister.

Currently, the `ecdsa_public_key` API supports generating P2PKH addresses.

### Generating a P2PKH address

To generate a P2PKH address for a canister, make a call to the `ecdsa_public_key_api`:

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```motoko

/// Returns the P2PKH address of this canister at a specific derivation path.
    public func get_p2pkh_address() : async BitcoinAddress {
        await BitcoinWallet.get_p2pkh_address(NETWORK, KEY_NAME, DERIVATION_PATH)
    };

```

</TabItem>
<TabItem value="rust" label="Rust">

```rust

/// Returns the P2PKH address of this canister at a specific derivation path.
#[update]
pub async fn get_p2pkh_address() -> String {
    let derivation_path = DERIVATION_PATH.with(|d| d.clone());
    let key_name = KEY_NAME.with(|kn| kn.borrow().to_string());
    let network = NETWORK.with(|n| n.get());
    bitcoin_wallet::get_p2pkh_address(network, key_name, derivation_path).await
}

```
</TabItem>
</AdornedTabs>

[Learn more about Bitcoin addresses](https://en.bitcoin.it/wiki/Transaction#Pay-to-PubkeyHash).

[Learn more about the `ecdsa_public_key` API](/docs/current/references/ic-interface-spec/#ic-ecdsa_public_key).

### Bitcoin addresses associated with Internet Identity

By default, your Internet Identity will have a Bitcoin address that can be used to send and receive BTC. You can view this address by logging into the [NNS frontend dapp](https://nns.ic0.app/) with your [Internet Identity](/docs/current/developer-docs/web-apps/user-login/internet-identity/overview). 

## Ethereum

On Ethereum, there are two types of addresses: wallet addresses for holding assets and contract addresses. Wallet addresses are public accounts that can send and receive ETH tokens. Contract addresses refer to a smart contract that has been executed on Ethereum and the transactions associated with that contract.

Wallet and contract addresses can be queried using the [EVM RPC canister](/docs/current/developer-docs/multi-chain/ethereum/evm-rpc/evm-rpc-canister).

### Generating a canister ETH address

To create an ETH address for your canister, first you will need to obtain an ECDSA public key associated to your canister. You can get this key by calling the `ecdsa_public_key` API method of the management canister:

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```motoko
  // Declare "ic" to be the management canister, which is evoked by `actor("aaaaa-aa")`.:
  let ic : IC = actor("aaaaa-aa");

  public shared (msg) func public_key() : async { #Ok : { public_key: Blob }; #Err : Text } {
    let caller = Principal.toBlob(msg.caller);

    try {

      // Make a call to the management canister to request an ECDSA public key:
      let { public_key } = await ic.ecdsa_public_key({
          canister_id = null;
          derivation_path = [ caller ];
          key_id = { curve = #secp256k1; name = "test_key_1" };
      });

      #Ok({ public_key })

    } catch (err) {

      #Err(Error.message(err))

    }

  };
```

</TabItem>

<TabItem value="rust" label="Rust" default>

```rust
#[update]
async fn public_key() -> Result<PublicKeyReply, String> {
    let request = ECDSAPublicKey {
        canister_id: None,
        derivation_path: vec![],
        key_id: EcdsaKeyIds::TestKeyLocalDevelopment.to_key_id(),
    };

    let (res,): (ECDSAPublicKeyReply,) =
        ic_cdk::call(mgmt_canister_id(), "ecdsa_public_key", (request,))
            .await
            .map_err(|e| format!("ecdsa_public_key failed {}", e.1))?;

    Ok(PublicKeyReply {
        public_key_hex: hex::encode(&res.public_key),
    })
}
```

</TabItem>
</AdornedTabs>


Then, convert the public key bytes to an Ethereum address. An example in Rust can be found below:

```rust
/// Converts the public key bytes to an Ethereum address with a checksum.
fn pubkey_bytes_to_address(pubkey_bytes: &[u8]) -> String {
    use k256::elliptic_curve::sec1::ToEncodedPoint;

    let key =
        PublicKey::from_sec1_bytes(pubkey_bytes).expect("failed to parse the public key as SEC1");
    let point = key.to_encoded_point(false);
    // we re-encode the key to the decompressed representation.
    let point_bytes = point.as_bytes();
    assert_eq!(point_bytes[0], 0x04);

    let hash = keccak256(&point_bytes[1..]);

    ethers_core::utils::to_checksum(&Address::from_slice(&hash[12..32]), None)
}
```

You can use this address to make Ethereum transactions from your canister.

[Learn how to sign Ethereum transactions](/docs/current/developer-docs/multi-chain/ethereum/using-eth/signing-transactions).

## Other chains

ICP canisters can create and manage wallet addresses for any blockchain that uses the ECDSA signature scheme. This signature scheme is used for chains such as Ethereum, EVM-compatible chains such as Polygon, and other non-EVM chains such as Sui.

This section will demonstrate examples of how non-EVM addresses can be generated and signed using the ICP [threshold ECDSA](/docs/current/developer-docs/smart-contracts/encryption/t-ecdsa) feature, since an ECDSA-based public key generated by an ICP canister can be derived into an unlimited amount of addresses on multiple chains.

For a canister to generate a threshold ECDSA public key, it will need to make a call to the [ICP management canister's](/docs/current/developer-docs/smart-contracts/advanced-features/management-canister) `ecdsa_public_key` endpoint.

### Sui

To generate a Sui address, you can write a function called `suiAddress` that calls the [ICP management canister](/docs/current/developer-docs/smart-contracts/advanced-features/management-canister). This call will generate an ECDSA public key, then the Sui SDK can be used to convert that public key into a Sui address.

Once you have a Sui address, you can write a function called `sign` that signs a transaction using your new Sui address.

An example of this workflow written in TypeScript can be found below:


```typescript
import { blob, Canister, text, ic, None, Record, update } from 'azle';
import { Secp256k1PublicKey } from '@mysten/sui/keypairs/secp256k1';
import { managementCanister } from 'azle/canisters/management';

const Signature = Record({
    signature: blob
});

export default Canister({
    suiAddress: update([], text, async () => {
        const caller = ic.caller().toUint8Array();

        const publicKeyResult = await ic.call(
            managementCanister.ecdsa_public_key,
            {
                args: [
                    {
                        canister_id: None,
                        derivation_path: [caller],
                        key_id: {
                            curve: { secp256k1: null },
                            name: 'dfx_test_key'
                        }
                    }
                ]
            }
        );

        const suiPublicKey = new Secp256k1PublicKey(publicKeyResult.public_key);
        const suiAddress = suiPublicKey.toSuiAddress();
        return suiAddress;
    }),
    sign: update([blob], Signature, async (messageHash) => {
        if (messageHash.length !== 32) {
            ic.trap('messageHash must be 32 bytes');
        }
        const caller = ic.caller().toUint8Array();
        const signatureResult = await ic.call(
            managementCanister.sign_with_ecdsa,
            {
                args: [
                    {
                        message_hash: messageHash,
                        derivation_path: [caller],
                        key_id: {
                            curve: { secp256k1: null },
                            name: 'dfx_test_key'
                        }
                    }
                ],
                cycles: 10_000_000_000n
            }
        );
        return {
            signature: signatureResult.signature
        };
    })
});
```

